<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Highlight Sentence Demo</title>
<style>
  .ProseMirror {
    border: 1px solid #ccc;
    padding: 10px;
    min-height: 150px;
    /* position: relative; is important for the overlay */
    position: relative; 
  }
  .highlight-overlay {
    position: absolute;
    background-color: rgba(255, 255, 0, 0.5);
    pointer-events: none;
    z-index: 1000;
  }
  button {
    margin-top: 10px;
  }
</style>
<!-- ProseMirror base CSS for correct layout/whitespace/icons -->
<link rel="stylesheet" href="https://unpkg.com/prosemirror-view/style/prosemirror.css">
<!-- ProseMirror doesn't publish UMD builds. Use ESM via a CDN like esm.sh -->
</head>
<body>
<h2>Highlight a Specific Sentence</h2>
<div id="editor"></div>
<button id="highlightBtn">Highlight Second Sentence</button>
<button id="clearBtn">Clear Highlights</button>

  <script type="module">
import {EditorState} from 'https://esm.sh/prosemirror-state@1.4.3';
import {EditorView} from 'https://esm.sh/prosemirror-view@1.31.8';
import {Schema, DOMParser as PMDOMParser} from 'https://esm.sh/prosemirror-model@1.20.0';
import {schema as basicSchema} from 'https://esm.sh/prosemirror-schema-basic@1.2.2';
import {exampleSetup} from 'https://esm.sh/prosemirror-example-setup@1.2.2';

// Initialize ProseMirror editor
const view = new EditorView(document.querySelector('#editor'), {
  state: EditorState.create({
    doc: basicSchema.node('doc', null, [
      basicSchema.node('paragraph', null, basicSchema.text(
        'This is the first sentence. Here is the second sentence that we will highlight. And this is the third sentence.'
      ))
    ]),
    plugins: exampleSetup({ schema: basicSchema })
  })
});

// Create overlay container positioned over the editor content
const overlayContainer = document.createElement('div');
overlayContainer.style.position = 'absolute';
overlayContainer.style.left = '0';
overlayContainer.style.top = '0';
overlayContainer.style.right = '0';
overlayContainer.style.bottom = '0';
overlayContainer.style.pointerEvents = 'none';
view.dom.appendChild(overlayContainer);

const highlights = [];

// Helper to create a valid DOM Range boundary from a ProseMirror position
function getDomPoint(pos) {
  const { node, offset } = view.domAtPos(pos);
  if (node.nodeType === Node.TEXT_NODE) return { node, offset };
  const child = node.childNodes[offset] || node.childNodes[node.childNodes.length - 1];
  if (child) {
    if (child.nodeType === Node.TEXT_NODE) {
      const textLen = child.nodeValue ? child.nodeValue.length : 0;
      return { node: child, offset: Math.min(offset, textLen) };
    }
    const walker = document.createTreeWalker(child, NodeFilter.SHOW_TEXT);
    const textNode = walker.nextNode();
    if (textNode) return { node: textNode, offset: 0 };
  }
  return { node: view.dom, offset: view.dom.childNodes.length };
}

function highlightRange(startPos, endPos) {
  const editorRect = view.dom.getBoundingClientRect();
  const domStart = getDomPoint(startPos);
  const domEnd = getDomPoint(endPos);
  console.log('[highlightRange]', { startPos, endPos, editorRect, domStart, domEnd });
  const range = document.createRange();
  try {
    range.setStart(domStart.node, domStart.offset);
    range.setEnd(domEnd.node, domEnd.offset);
  } catch (e) {
    console.warn('Failed to set DOM Range for highlight', e);
    return;
  }

  const rects = Array.from(range.getClientRects());
  console.log('[highlightRange] rects', rects);
  if (rects.length > 0) {
    rects.forEach(r => {
      const div = document.createElement('div');
      div.className = 'highlight-overlay';
      div.style.left = (r.left - editorRect.left) + 'px';
      div.style.top = (r.top - editorRect.top) + 'px';
      div.style.width = r.width + 'px';
      div.style.height = r.height + 'px';
      div.style.outline = '1px solid red';
      overlayContainer.appendChild(div);
      highlights.push(div);

      // DEBUG: also draw a viewport-fixed overlay to verify rect coordinates
      const fixed = document.createElement('div');
      fixed.style.position = 'fixed';
      fixed.style.left = r.left + 'px';
      fixed.style.top = r.top + 'px';
      fixed.style.width = r.width + 'px';
      fixed.style.height = r.height + 'px';
      fixed.style.pointerEvents = 'none';
      fixed.style.outline = '1px dashed blue';
      fixed.style.zIndex = 2000;
      fixed.className = 'highlight-overlay debug-fixed';
      document.body.appendChild(fixed);
      highlights.push(fixed);
    });
    return;
  }

  // Fallback: use coordsAtPos when Range rects are empty
  const start = view.coordsAtPos(startPos);
  const end = view.coordsAtPos(endPos);
  console.log('[highlightRange] fallback coords', { start, end });

  // If on the same line
  if (Math.abs(start.top - end.top) < 2) {
    const div = document.createElement('div');
    div.className = 'highlight-overlay';
    const top = start.top - editorRect.top;
    const left = Math.min(start.left, end.left) - editorRect.left;
    const width = Math.abs(end.left - start.left);
    const height = Math.max(start.bottom, end.bottom) - Math.min(start.top, end.top);
    div.style.top = top + 'px';
    div.style.left = left + 'px';
    div.style.width = width + 'px';
    div.style.height = height + 'px';
    div.style.outline = '1px solid red';
    overlayContainer.appendChild(div);
    highlights.push(div);
  } else {
    // Simple multi-line fallback: one rect from start to line end, one from line start to end
    const lineHeightStart = start.bottom - start.top;
    const div1 = document.createElement('div');
    div1.className = 'highlight-overlay';
    div1.style.top = (start.top - editorRect.top) + 'px';
    div1.style.left = (start.left - editorRect.left) + 'px';
    div1.style.width = (editorRect.right - start.left) + 'px';
    div1.style.height = lineHeightStart + 'px';
    div1.style.outline = '1px solid red';
    overlayContainer.appendChild(div1);
    highlights.push(div1);

    const lineHeightEnd = end.bottom - end.top;
    const div2 = document.createElement('div');
    div2.className = 'highlight-overlay';
    div2.style.top = (end.top - editorRect.top) + 'px';
    div2.style.left = '0px';
    div2.style.width = (end.left - editorRect.left) + 'px';
    div2.style.height = lineHeightEnd + 'px';
    div2.style.outline = '1px solid red';
    overlayContainer.appendChild(div2);
    highlights.push(div2);
  }
}

function clearHighlights() {
  highlights.forEach(div => div.remove());
  highlights.length = 0;
}

document.getElementById('highlightBtn').addEventListener('click', () => {
  clearHighlights();
  const paragraph = view.state.doc.firstChild;
  const text = paragraph.textContent;
  const sentences = text.match(/[^\.!\?]+[\.!\?]+/g) || [];
  if (sentences.length < 2) return;
  const secondSentence = sentences[1].trim();
  const offset = text.indexOf(secondSentence);
  if (offset === -1) return;
  const highlightStart = offset + 1; // First text pos in a block is 1
  const highlightEnd = highlightStart + secondSentence.length;
  highlightRange(highlightStart, highlightEnd);
});

document.getElementById('clearBtn').addEventListener('click', clearHighlights);
  </script>
</body>
</html>